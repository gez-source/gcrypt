#ifndef GCRYPT_H
#define GCRYPT_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>

#define FILE_BUFFER_SIZE 8000

const int security_rounds = 40;

const char* hex_prefix = "0x";

unsigned int a = 0;
unsigned int b = 0;
unsigned int c = 0;
unsigned int d = 0;
unsigned int e = 0;

unsigned int prime = 0;
unsigned int prime2 = 0;
unsigned int prime3 = 0;
unsigned int prime4 = 0;
unsigned int prime5 = 0;

//  see: https://stackoverflow.com/questions/35167/is-there-a-way-to-perform-a-circular-bit-shift-in-c
#define GCRYPT_CIRCULAR_LEFT_SHIFT(value,n) (value << n) | (value >> (32 - n))
#define GCRYPT_CIRCULAR_RIGHT_SHIFT(value,n) (value >> n) | (value << (32 - n))
// End of code import.

/// <summary>
/// Initilises the state of the hash function.
/// </summary>
void gcrypt_initilise_state()
{
	// Primes generated by bigprimes.org.
	prime = 53893699;
	prime2 = 29602757;
	prime3 = 69409363;
	prime4 = 64997063;
	prime5 = 49541567;

	// Hash state information.
	a = 19342607;
	b = 84843461;
	c = 18026741;
	d = 36106927;
	e = 42463199; // More prime numbers.
}

void gcrypt_int_to_hex(unsigned int integer, unsigned char hexOutput[8])
{
	// Hex value is 8 digits long for a uint.
	hexOutput[8] = '0';

	sprintf(hexOutput, "%x", integer);
}

// see: https://stackoverflow.com/questions/43354488/c-formatted-string-how-to-add-leading-zeros-to-string-value-using-sprintf
// prepend "0" as needed resulting in a string of _minimal_ width.
void gcrypt_prepend_zeros(char* dest, const char* src, unsigned minimal_width, char padding_char)
{
	int len = strlen(src);
	int zeros = (len > minimal_width) ? 0 : minimal_width - len;
	memset(dest, padding_char, zeros);
	strcpy(dest + zeros, src);
}
// end of code import.

void gcrypt_state_to_hash(unsigned char outputHash[43])
{	
	unsigned char padding[9];

	memset(outputHash, 0, 43);

	memset(padding, '0', 9);
	outputHash[0] = '0';
	outputHash[1] = 'x';

	gcrypt_int_to_hex(a, padding);
	gcrypt_prepend_zeros(padding, padding, 8, '0');
	strcat(outputHash, padding);

	gcrypt_int_to_hex(b, padding);
	gcrypt_prepend_zeros(padding, padding, 8, '0');
	strcat(outputHash, padding);

	gcrypt_int_to_hex(c, padding);
	gcrypt_prepend_zeros(padding, padding, 8, '0');
	strcat(outputHash, padding);

	gcrypt_int_to_hex(d, padding);
	gcrypt_prepend_zeros(padding, padding, 8, '0');
	strcat(outputHash, padding);

	gcrypt_int_to_hex(e, padding);
	gcrypt_prepend_zeros(padding, padding, 8, '0');
	strcat(outputHash, padding);
}

/// <summary>
/// Performs a round over the state of the hash function.
/// </summary>
void gcrypt_execute_round()
{
	int l_rotate[] = { 5, 2, 1, 4, 7, 12 };
	int r_rotate[] = { 14, 3, 5, 8, 11, 6 };

	for (int roundNum = 0; roundNum < security_rounds; roundNum++)
	{
		if (roundNum % 4 == 0)
		{
			a = GCRYPT_CIRCULAR_RIGHT_SHIFT(a, 13);
		}
		if (roundNum % 3 == 0)
		{
			a = GCRYPT_CIRCULAR_LEFT_SHIFT(a, 7);
		}

		a = GCRYPT_CIRCULAR_LEFT_SHIFT(a, l_rotate[roundNum % 6]);
		a = GCRYPT_CIRCULAR_RIGHT_SHIFT(a, r_rotate[roundNum % 6]);

		a = (a ^ b);
		a = (a ^ c);
		a = (a ^ d);
		a = (a ^ e);

		b = (b ^ a);
		b = (b ^ c);
		b = (b ^ d);
		b = (b ^ e);

		c = (c ^ a);
		c = (c ^ b);
		c = (c ^ d);
		c = (c ^ e);

		d = (d ^ a);
		d = (d ^ b);
		d = (d ^ c);
		d = (d ^ e);

		e = (e ^ a);
		e = (e ^ b);
		e = (e ^ c);
		e = (e ^ d);
	}
}

/// <summary>
/// Processand shred the specified byte into hash state.
/// </summary>
void gcrypt_process_byte_to_hash(unsigned char byteInput)
{
	// Combine current byteInput with state.
	a = (a ^ byteInput) * prime;
	b = (b ^ byteInput) * prime2;
	c = (c ^ byteInput) * prime3;
	d = (d ^ byteInput) * prime4;
	e = (e ^ byteInput) * prime5;

	// Execute the specified number of rounds shuffling hash state some more.
	gcrypt_execute_round();
}

/// <summary>
/// Hash the specified input string and return the resultant hash as a string.
/// </summary>
void gcrypt_ghash(char* inputString, unsigned char outputHash[43])
{
	gcrypt_initilise_state();
	gcrypt_execute_round();

	for (int i = 0; i < strlen(inputString); i++)
	{
		uint8_t c = inputString[i];

		gcrypt_process_byte_to_hash(c);
	}

	gcrypt_state_to_hash(outputHash);
}

void gcrypt_ghash_file(char* fileName, char** outputHash, char** padded)
{
	gcrypt_initilise_state();
	gcrypt_execute_round();

	uint8_t buffer[FILE_BUFFER_SIZE] = { 0 };
	int bytesRead = 0;
	int i;
	int bufferSize = sizeof(buffer);

	FILE* fp = fopen(fileName, "rb");

	if (!fp) 
	{
		fprintf(stderr, "error: file open failed '%s'.\n", fileName);
		return 1;
	}

	while ((bytesRead = fread(buffer, sizeof * buffer, bufferSize, fp)) == bufferSize)
	{
		for (i = 0; i < bufferSize; i++)
		{
			gcrypt_process_byte_to_hash(buffer[i]);
		}
	}

	for (i = 0; i < bytesRead; i++)
	{
		gcrypt_process_byte_to_hash(buffer[i]);
	}

	if (fp != stdin)
	{
		fclose(fp);
	}

	gcrypt_state_to_hash(outputHash, padded);
}

#endif