using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

public class GCrypt
{
    public static string Hash(string input)
    {
        byte[] data = Encoding.UTF8.GetBytes(input);
        string result = Hash(data);
        return result;
    }

    public static void ExecuteRound(ref uint a, ref uint b, ref uint c, ref uint d, ref uint e)
    {
        byte[] l_rotate = { 5, 2, 1, 4, 7, 12 };
        byte[] r_rotate = { 14, 3, 5, 8, 11, 6 };

        // Mixes the state to perform the avalanche effect the specified number of times.
        for (int roundNum = 0; roundNum < 40; roundNum++)
        {
            if (roundNum % 4 == 0) a = CircularRightShift(a, 13);

            if (roundNum % 3 == 0) a = CircularLeftShift(a, 7);

            a = CircularLeftShift(a, l_rotate[roundNum % 6]);
            a = CircularRightShift(a, r_rotate[roundNum % 6]);

            a = (a ^ b);
            a = (a ^ c);
            a = (a ^ d);
            a = (a ^ e);

            b = (b ^ a);
            b = (b ^ c);
            b = (b ^ d);
            b = (b ^ e);

            c = (c ^ a);
            c = (c ^ b);
            c = (c ^ d);
            c = (c ^ e);

            d = (d ^ a);
            d = (d ^ b);
            d = (d ^ c);
            d = (d ^ e);

            e = (e ^ a);
            e = (e ^ b);
            e = (e ^ c);
            e = (e ^ d);
        }
    }

    public static void ProcessByteToHash(byte byteInput, ref uint a, ref uint b, ref uint c, ref uint d, ref uint e,
        uint prime, uint prime2, uint prime3, uint prime4, uint prime5)
    {
        a = (a ^ byteInput) * prime;
        b = (b ^ byteInput) * prime2;
        c = (c ^ byteInput) * prime3;
        d = (d ^ byteInput) * prime4;
        e = (e ^ byteInput) * prime5;

        ExecuteRound(ref a, ref b, ref c, ref d, ref e);
    }

    public static string StateToHash(uint a, uint b, uint c, uint d, uint e)
    {
        string hash = "0x" + a.ToString("x8") + b.ToString("x8") + c.ToString("x8")
            + d.ToString("x8") + e.ToString("x8");

        return hash;
    }

    public static string HashFile(string fileName)
    {
        // Primes generated by bigprimes.org.
        uint prime = 53893699;
        uint prime2 = 29602757;
        uint prime3 = 69409363;
        uint prime4 = 64997063;
        uint prime5 = 49541567;

        // State:
        uint a = 19342607;
        uint b = 84843461;
        uint c = 18026741;
        uint d = 36106927;
        uint e = 42463199; // More prime numbers.

        ExecuteRound(ref a, ref b, ref c, ref d, ref e);


        if (!File.Exists(fileName))
        {
            Console.WriteLine("File " + fileName + " does not exists!");
            return "";
        }

        // Create Stream object via constructor of FileStream
        // FileMode.Open: Open file to read.
        using (Stream readingStream = new FileStream(fileName, FileMode.Open))
        {
            byte[] byteBuffer = new byte[8000];
            UTF8Encoding encoding = new UTF8Encoding(true);

            int bytesToRead = 0;

            while ((bytesToRead = readingStream.Read(byteBuffer, 0, byteBuffer.Length)) > 0)
            {
                for(int i = 0; i < bytesToRead; i++)
                {
                    byte byteInput = byteBuffer[i];

                    ProcessByteToHash(byteInput, ref a, ref b, ref c, ref d, ref e, prime, prime2, prime3, prime4, prime5);
                }
            }
        }

        return StateToHash(a, b, c, d, e);
    }

    public static string Hash(byte[] data)
    {
        // Primes generated by bigprimes.org.
        uint prime = 53893699;
        uint prime2 = 29602757;
        uint prime3 = 69409363;
        uint prime4 = 64997063;
        uint prime5 = 49541567;

        // State:
        uint a = 19342607;
        uint b = 84843461;
        uint c = 18026741;
        uint d = 36106927;
        uint e = 42463199; // More prime numbers.

        ExecuteRound(ref a, ref b, ref c, ref d, ref e);

        int i;
        byte byteInput;

        for (i = 0; i < data.Length; i++)
        {
            byteInput = data[i];

            ProcessByteToHash(byteInput, ref a, ref b, ref c, ref d, ref e, prime, prime2, prime3, prime4, prime5);
        }

        return StateToHash(a, b, c, d, e);
    }

    public static string GetString(byte[] byteArray)
    {
        StringBuilder hex = new StringBuilder(byteArray.Length * 2);
        foreach (byte b in byteArray)
        {
            hex.AppendFormat("{0:x2}", b);
        }
        return hex.ToString();
    }

    //  see: https://stackoverflow.com/questions/35167/is-there-a-way-to-perform-a-circular-bit-shift-in-c
    public static uint CircularLeftShift(uint value, byte n)
    {
        return (uint)((value << n) | (value >> (32 - n)));

        //uint result = (uint)(((int)(value) << (int)n) | ((int)(value) >> (32 - (int)n)));
        //return result;
    }
    // end of code import

    // see: http://www.interviewdruid.com/circular-left-shift-and-circular-right-shift-on-integer/
    public static uint CircularRightShift(uint value, byte n)
    {
        return (uint)((value >> n) | (value << (32 - n)));
        //uint result = (uint)(((int)(value) >> (int)n) | ((int)(value) << (32 - (int)n)));
        //return result;
    }
    // end of code import
}
