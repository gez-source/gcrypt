# Name: Gerallt Franke
# Program Name: gcrypt hashing algorithm
# Python version: 3.9.5

import time     # for timing of computation.
import ctypes   # for uint32.

class GCrypt:
    # Options for the character set to bruteforce:
    charsetLowerUpperAlphaNumeric = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ";
    charsetLowerAlphaNumeric = "abcdefghijklmnopqrstuvwxyz";
    charset = charsetLowerAlphaNumeric; # Current character set.

    # The number of rounds to shuffle hash state.
    security_rounds = 40 # Ideally at least should be 40 or more except it can be slow for large files.

    # Start of the hash string.
    hex_prefix = "0x"

    # The encoding of the input string to the hash function.
    encoding = "utf-8"

    # Big or little endian.
    endian_type = "big"

    # Logging
    trace_enabled = False

    # Current version of program.
    version = "0.1"

    # State of hash function
    a = 0
    b = 0
    c = 0
    d = 0
    e = 0
    
    prime = 0
    prime2 = 0
    prime3 = 0
    prime4 = 0
    prime5 = 0

    timeStarted = 0
    timeStopped = 0
    
    def __init__(self):
        print("gcrypt version " + self.version)

    # Start timing a task.
    def startTimer(self):
        self.timeStarted = time.perf_counter()

    # Stop timing a task.    
    def stopTimer(self):
        self.timeStopped = time.perf_counter()

    # Print the time taken to complete a task.
    def printTime(self):
        print("Completed in " + str(self.timeStopped - self.timeStarted) + " seconds.")
        
    def xor(self, a, b):
        # A long integer was returned when the result exceeded the limit of integers.
        # see: https://stackoverflow.com/questions/45480641/bitwise-xor-operator-not-working-in-python
        return ctypes.c_uint32((a ^ b)).value & 0xffffffff # stick to using 32 a bit integer instead of default long.
        # end of code import

    # see: http://www.interviewdruid.com/circular-left-shift-and-circular-right-shift-on-integer/
    # value: input value which has to be circularly shifted left
    # n: number of positions to shift
    # Return value: result after circularly left shifting input value
    def circular_left_shift(self, value, n) :
        return ctypes.c_uint32((value << abs(n)) | (value >> abs(32 - n))).value
    # end of code import
    
    # see: http://www.interviewdruid.com/circular-left-shift-and-circular-right-shift-on-integer/
    # value: input value which has to be circularly shifted right
    # n: number of positions to shift
    # Return value: result after circularly right shifting input value
    def circular_right_shift(self, value, n) :
        return ctypes.c_uint32((value >> abs(n)) | (value << abs(32 - n))).value
    # end of code import

    # Convert integer to hexadecimal number without 0x prefix.
    def int_to_hex(self, integer):
        return format(integer, "x")

    # Initilises the state of the hash function.
    def initilise_state(self):
        # Primes generated by bigprimes.org.
        self.prime = 53893699
        self.prime2 = 29602757
        self.prime3 = 69409363
        self.prime4 = 64997063
        self.prime5 = 49541567

        # Hash state information.
        self.a = 19342607
        self.b = 84843461
        self.c = 18026741
        self.d = 36106927
        self.e = 42463199 # More prime numbers.

    # Perform a round of shuffling of the state using xor and circular shift bitwise operations.
    def execute_round(self):
        l_rotate = [5, 2, 1, 4, 7, 12]
        r_rotate = [14, 3, 5, 8, 11, 6]

        for roundNum in range(0, 40):
            if(roundNum % 4 == 0):
                self.a = self.circular_right_shift(self.a, 13)

            if(roundNum % 3 == 0):
                self.a = self.circular_left_shift(self.a, 7)

            self.a = self.circular_left_shift(self.a, l_rotate[roundNum % 6])
            self.a = self.circular_right_shift(self.a, r_rotate[roundNum % 6])
            
            self.a = self.xor(self.a, self.b)
            self.a = self.xor(self.a, self.c)
            self.a = self.xor(self.a, self.d)
            self.a = self.xor(self.a, self.e)

            self.b = self.xor(self.b, self.a)
            self.b = self.xor(self.b, self.c)
            self.b = self.xor(self.b, self.d)
            self.b = self.xor(self.b, self.e)

            self.c = self.xor(self.c, self.a)
            self.c = self.xor(self.c, self.b)
            self.c = self.xor(self.c, self.d)
            self.c = self.xor(self.c, self.e)

            self.d = self.xor(self.d, self.a)
            self.d = self.xor(self.d, self.b)
            self.d = self.xor(self.d, self.c)
            self.d = self.xor(self.d, self.e)

            self.e = self.xor(self.e, self.a)
            self.e = self.xor(self.e, self.b)
            self.e = self.xor(self.e, self.c)
            self.e = self.xor(self.e, self.d)

        
    # Process and shred the specified byte into hash state.
    def process_byte_to_hash(self, byteInput):        
        # Combine current byteInput with state.
        self.a = ctypes.c_uint32(self.xor(self.a, byteInput)).value
        self.a = ctypes.c_uint32(self.xor(self.a, byteInput) * self.prime).value
        self.b = ctypes.c_uint32(self.xor(self.b, byteInput) * self.prime2).value
        self.c = ctypes.c_uint32(self.xor(self.c, byteInput) * self.prime3).value
        self.d = ctypes.c_uint32(self.xor(self.d, byteInput) * self.prime4).value
        self.e = ctypes.c_uint32(self.xor(self.e, byteInput) * self.prime5).value
        
        # Execute the specified number of rounds shuffling hash state some more.
        self.execute_round()
        
    def state_to_hash(self):
        # Formulate resultant hash using state information.
        # Ensure each 32bit value is exactly 8 characters long (use padding if required.)
        hex_string = self.int_to_hex(self.a).zfill(8) + self.int_to_hex(self.b).zfill(8) + \
                     self.int_to_hex(self.c).zfill(8) + self.int_to_hex(self.d).zfill(8) + \
                     self.int_to_hex(self.e).zfill(8)

        # Ensure output is fitted to 32 characters with a padding of zeros.
        #hex_string = hex_string.zfill(40) 
        
        return self.hex_prefix + hex_string

    # Hash the specified byte array and return the resultant hash as a string.
    def ghash_bytes(self, inputBytes):
        self.initilise_state()
        self.execute_round()
        
        # Iterate through all the bytes in the inputString.
        for byteInput in inputBytes:
            self.process_byte_to_hash(byteInput)

        return self.state_to_hash()

    # Hash the specified input string and return the resultant hash as a string.
    def ghash(self, inputString):
        if self.trace_enabled:
            print("ghash(): input string to hash: '" + inputString + "'")

        # Convert the input string to byte array using the specified encoding.
        inputBytes = bytearray(inputString, self.encoding)
        
        return self.ghash_bytes(inputBytes)

    # Hash the specified file and return the resultant hash as a string.
    def ghash_file(self, filePath):
        self.initilise_state()
        #self.execute_round()
        
        self.startTimer()
        if self.trace_enabled:
            print("ghash_file(): input file: '" + filePath + "'")
        file = open(filePath, "rb")
        byteInput = file.read(1)
        while byteInput:
            self.process_byte_to_hash(byteInput[0])
            byteInput = file.read(1)
            
        self.stopTimer()
        self.printTime()
        return self.state_to_hash()
        
    # Execute a simple bruteforce from aaa-zzz.
    def bruteforce_simple(self):
        if self.trace_enabled:
            print("bruteforce_simple(): input character set '" + self.charset + "'")
        # Iterate through all key search space in a cascade to generate a plaintext for hashing function.
        for x in self.charset: 
            for y in self.charset:    
                for z in self.charset:
                    for a in self.charset:
                        # Assemble characters into sequence.
                        plaintext = x + y + z + a
                        
                        # Execute hash algorithm on plaintext.
                        print(plaintext + " " + self.ghash(plaintext))
                    
    def find_collisions(self):
        print("Looking for collisions..")
        hashSet=set()
        numCollisions = 0
        # Iterate through all key search space in a cascade to generate a plaintext for hashing function.
        for x in self.charset: 
            for y in self.charset:    
                for z in self.charset:
                    for a in self.charset:
                        # Assemble characters into sequence.
                        plaintext = x + y + z + a

                        # Execute hash function on plaintext.
                        hashtext = self.ghash(plaintext)

                        # Add to set if it's not contained within, otherwise update collision count.
                        if hashtext not in hashSet:
                            hashSet.add(hashtext)
                        else:
                            numCollisions += 1
                            
                        print(plaintext + " " + hashtext + " collisions: " + str(numCollisions))

g = GCrypt()
print(g.ghash("The quick brown fox jumps over the lazy dog"))  # should be: 
print(g.ghash("The quick brown fox jumps over the lazy dog.")) # should be: 
print(g.ghash("the quick brown fox jumps over the lazy dog")) # should be:  
print(g.ghash("")) # should be:

#g.bruteforce_simple() # Run a test bruteforce of the hashing algorithm.
#g.find_collisions()

#print(g.ghash_file("test.txt"))

print("done.")
