# Name: Gerallt Franke
# Student ID: 138793
# Program Name: ZAT113 AT3 - gcrypt hashing algorithm
# Python version: 3.9.5

import time     # for timing of computation.
import ctypes   # for uint32.

class gCrypt:
    # Options for the character set to bruteforce:
    charsetLowerUpperAlphaNumeric = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ";
    charsetLowerAlphaNumeric = "abcdefghijklmnopqrstuvwxyz";
    charset = charsetLowerAlphaNumeric; # Current character set.

    # The number of rounds to shuffle hash state.
    securityRounds = 40 # Ideally at least should be 40 or more except it can be slow for large files.

    # Start of the hash string.
    hexPrefix = "0x"

    # The encoding of the input string to the hash function.
    encoding = "utf-8"

    # Logging
    traceEnabled = False

    # Current version of program.
    version = "0.1"

    # State of hash function
    a = 0
    b = 0
    c = 0
    d = 0
    e = 0
    
    prime = 0
    prime2 = 0
    prime3 = 0
    prime4 = 0
    prime5 = 0

    timeStarted = 0
    timeStopped = 0
    
    def __init__(self):
        print("gcrypt version {}".format(self.version))

    # Start timing a task.
    def startTimer(self):
        self.timeStarted = time.perf_counter()

    # Stop timing a task.    
    def stopTimer(self):
        self.timeStopped = time.perf_counter()

    # Print the time taken to complete a task.
    def printTime(self):
        print("Completed in " + str(self.timeStopped - self.timeStarted) + " seconds.")
        
    def xor(self, a, b):
        # A long integer was returned when the result exceeded the limit of integers.
        # see: https://stackoverflow.com/questions/45480641/bitwise-xor-operator-not-working-in-python
        return ctypes.c_uint32((a ^ b)).value & 0xffffffff # stick to using 32 a bit integer instead of default long.
        # end of code import

    # see: http://www.interviewdruid.com/circular-left-shift-and-circular-right-shift-on-integer/
    # value: input value which has to be circularly shifted left
    # n: number of positions to shift
    # Return value: result after circularly left shifting input value
    def circularLeftShift(self, value, n) :
        return ctypes.c_uint32((value << abs(n)) | (value >> abs(32 - n))).value
    # end of code import
    
    # see: http://www.interviewdruid.com/circular-left-shift-and-circular-right-shift-on-integer/
    # value: input value which has to be circularly shifted right
    # n: number of positions to shift
    # Return value: result after circularly right shifting input value
    def circularRightShift(self, value, n) :
        return ctypes.c_uint32((value >> abs(n)) | (value << abs(32 - n))).value
    # end of code import

    # Convert integer to hexadecimal number without 0x prefix.
    def intToHex(self, integer):
        return format(integer, "x")

    # Initilises the state of the hash function.
    def initiliseState(self):
        # Primes generated by bigprimes.org.
        self.prime = 53893699
        self.prime2 = 29602757
        self.prime3 = 69409363
        self.prime4 = 64997063
        self.prime5 = 49541567

        # Hash state information.
        self.a = 19342607
        self.b = 84843461
        self.c = 18026741
        self.d = 36106927
        self.e = 42463199 # More prime numbers.

    # Perform a round of shuffling of the state using xor and circular shift bitwise operations.
    def executeRound(self):
        l_rotate = [5, 2, 1, 4, 7, 12]
        r_rotate = [14, 3, 5, 8, 11, 6]

        for roundNum in range(0, self.securityRounds):
            if(roundNum % 4 == 0):
                self.a = self.circularRightShift(self.a, 13)

            if(roundNum % 3 == 0):
                self.a = self.circularLeftShift(self.a, 7)

            self.a = self.circularLeftShift(self.a, l_rotate[roundNum % 6])
            self.a = self.circularRightShift(self.a, r_rotate[roundNum % 6])
            
            self.a = self.xor(self.a, self.b)
            self.a = self.xor(self.a, self.c)
            self.a = self.xor(self.a, self.d)
            self.a = self.xor(self.a, self.e)

            self.b = self.xor(self.b, self.a)
            self.b = self.xor(self.b, self.c)
            self.b = self.xor(self.b, self.d)
            self.b = self.xor(self.b, self.e)

            self.c = self.xor(self.c, self.a)
            self.c = self.xor(self.c, self.b)
            self.c = self.xor(self.c, self.d)
            self.c = self.xor(self.c, self.e)

            self.d = self.xor(self.d, self.a)
            self.d = self.xor(self.d, self.b)
            self.d = self.xor(self.d, self.c)
            self.d = self.xor(self.d, self.e)

            self.e = self.xor(self.e, self.a)
            self.e = self.xor(self.e, self.b)
            self.e = self.xor(self.e, self.c)
            self.e = self.xor(self.e, self.d)

        
    # Process and shred the specified byte into hash state.
    def processByteToHash(self, byteInput):        
        # Combine current byteInput with state.
        self.a = ctypes.c_uint32(self.xor(self.a, byteInput)).value
        self.a = ctypes.c_uint32(self.xor(self.a, byteInput) * self.prime).value
        self.b = ctypes.c_uint32(self.xor(self.b, byteInput) * self.prime2).value
        self.c = ctypes.c_uint32(self.xor(self.c, byteInput) * self.prime3).value
        self.d = ctypes.c_uint32(self.xor(self.d, byteInput) * self.prime4).value
        self.e = ctypes.c_uint32(self.xor(self.e, byteInput) * self.prime5).value
        
        # Execute the specified number of rounds shuffling hash state some more.
        self.executeRound()
        
    def stateToHash(self):
        # Formulate resultant hash using state information.
        # Ensure each 32bit value is exactly 8 characters long (use padding if required.)
        hex_string = self.intToHex(self.a).zfill(8) + self.intToHex(self.b).zfill(8) + \
                     self.intToHex(self.c).zfill(8) + self.intToHex(self.d).zfill(8) + \
                     self.intToHex(self.e).zfill(8)

        # Ensure output is fitted to 32 characters with a padding of zeros.
        #hex_string = hex_string.zfill(40) 
        
        return self.hexPrefix + hex_string

    # Hash the specified byte array and return the resultant hash as a string.
    def ghashBytes(self, inputBytes):
        self.initiliseState()
        self.executeRound()
        
        # Iterate through all the bytes in the inputString.
        for byteInput in inputBytes:
            self.processByteToHash(byteInput)

        return self.stateToHash()

    # Hash the specified input string and return the resultant hash as a string.
    def ghashString(self, inputString):
        if self.traceEnabled:
            print("ghash(): input string to hash: '" + inputString + "'")

        # Convert the input string to byte array using the specified encoding.
        inputBytes = bytearray(inputString, self.encoding)
        
        return self.ghashBytes(inputBytes)

    # Hash the specified file and return the resultant hash as a string.
    def ghashFile(self, filePath):
        self.initiliseState()
        self.executeRound()
        
        self.startTimer()
        if self.traceEnabled:
            print("ghashFile(): input file: '" + filePath + "'")
        file = open(filePath, "rb")
        byteInput = file.read(1)
        while byteInput:
            self.processByteToHash(byteInput[0])
            byteInput = file.read(1)
            
        self.stopTimer()
        self.printTime()
        return self.stateToHash()
        
    # Execute a simple bruteforce from aaa-zzz.
    def bruteforceSimple(self):
        if self.traceEnabled:
            print("bruteforceSimple(): input character set '" + self.charset + "'")
        # Iterate through all key search space in a cascade to generate a plaintext for hashing function.
        for x in self.charset: 
            for y in self.charset:    
                for z in self.charset:
                    for a in self.charset:
                        # Assemble characters into sequence.
                        plaintext = x + y + z + a
                        
                        # Execute hash algorithm on plaintext.
                        print(plaintext + " " + self.ghashString(plaintext))
                    
    def findCollisions(self):
        print("Looking for collisions..")
        hashSet=set()
        numCollisions = 0
        # Iterate through all key search space in a cascade to generate a plaintext for hashing function.
        for x in self.charset: 
            for y in self.charset:    
                for z in self.charset:
                    for a in self.charset:
                        # Assemble characters into sequence.
                        plaintext = x + y + z + a

                        # Execute hash function on plaintext.
                        hashtext = self.ghashString(plaintext)

                        # Add to set if it's not contained within, otherwise update collision count.
                        if hashtext not in hashSet:
                            hashSet.add(hashtext)
                        else:
                            numCollisions += 1
                            
                        print(plaintext + " " + hashtext + " collisions: " + str(numCollisions))

